// Code generated by excelconfc. DO NOT EDIT.
// source:
//   file: ExcelConfTest.xlsx
//   sheet: ArrayAndBDTVecConf

package excelconf

import (
	"encoding/json"
	"encoding/xml"
	"os"
)

type IntStruct struct {
	IVec   []int32 `json:"i_vec,omitempty" xml:"i_vec>item"`
	IArray []int32 `json:"i_array,omitempty" xml:"i_array>item"`
}

type ArrayAndBDTVecConf struct {
	Id         int32       `json:"id,omitempty" xml:"id"`
	IntVec     []int32     `json:"int_vec,omitempty" xml:"int_vec>item"`
	IntArray   []int32     `json:"int_array,omitempty" xml:"int_array>item"`
	IntStructs []IntStruct `json:"int_structs,omitempty" xml:"int_structs>item"`
}

type ArrayAndBDTVecConfMap map[int32]*ArrayAndBDTVecConf

func (s ArrayAndBDTVecConfMap) LoadFromJsonFile(filePath string) error {
	fileBytes, err := os.ReadFile(filePath)
	if err != nil {
		return err
	}
	jsonData := struct {
		Data []ArrayAndBDTVecConf `json:"data"`
	}{}
	if err := json.Unmarshal(fileBytes, &jsonData); err != nil {
		return err
	}
	for _, conf := range jsonData.Data {
		s[conf.Id] = &conf
	}
	return nil
}

func (s ArrayAndBDTVecConfMap) LoadFromXmlFile(filePath string) error {
	fileBytes, err := os.ReadFile(filePath)
	if err != nil {
		return err
	}
	xmlData := struct {
		Data []*ArrayAndBDTVecConf `xml:"all_infos>item"`
	}{}
	if err := xml.Unmarshal(fileBytes, &xmlData); err != nil {
		return err
	}
	for _, conf := range xmlData.Data {
		s[conf.Id] = conf
	}
	return nil
}

func (s ArrayAndBDTVecConfMap) GetVal(key int32) *ArrayAndBDTVecConf {
	return s[key]
}

var instanceArrayAndBDTVecConfMap = make(ArrayAndBDTVecConfMap)

func GetArrayAndBDTVecConfMapInst() ArrayAndBDTVecConfMap {
	return instanceArrayAndBDTVecConfMap
}
